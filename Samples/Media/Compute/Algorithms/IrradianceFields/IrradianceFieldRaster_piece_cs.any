
//#include "SyntaxHighlightingMisc.h"

/// This compute shader simply converts 2 cubemaps (colour & depth) of the same resolution
/// into 2 2D textures in octahedral mapping, which may be in different resolution,
/// assuming depth_resolution >= colour_resolution

@piece( HeaderCS )
	INLINE ushort2 getIrradianceFieldColourBaseXY( ProbeIndex probeIdx )
	{
		ushort2 retVal;
		retVal.x = (probeIdx * @value( colour_resolution )u) % @value( colour_full_width )u;
		retVal.y = ((probeIdx * @value( colour_resolution )u) / @value( colour_full_width )u) *
					@value( colour_resolution )u;

		return retVal;
	}

	INLINE ushort2 depthXyToColourXy( ushort2 depthXy )
	{
		return depthXy / @value( depth_to_colour_resolution_ratio )u;
	}

	INLINE float3 octahedronMappingDecode( float2 f )
	{
		// https://twitter.com/Stubbesaurus/status/937994790553227264
		float3 n = float3( f.x, f.y, 1.0f - abs( f.x ) - abs( f.y ) );
		float t = saturate( -n.z );
		n.x += n.x >= 0 ? -t : t;
		n.y += n.y >= 0 ? -t : t;
		return normalize( n );
	}
@end

//in uvec3 gl_NumWorkGroups;
//in uvec3 gl_WorkGroupID;
//in uvec3 gl_LocalInvocationID;
//in uvec3 gl_GlobalInvocationID;
//in uint  gl_LocalInvocationIndex;

@piece( BodyCS )
	ushort2 irradianceFieldColourBaseXY = getIrradianceFieldColourBaseXY( p_probeIdx );

	ushort2 iColourXY = irradianceFieldColourBaseXY + gl_LocalInvocationID.xy;
	ushort2 iDepthXY = iColourXY * @value( depth_to_colour_resolution_ratio )u;

	float2 samplingXY = float2( gl_LocalInvocationID.xy ) / @value( colour_full_width );

	float2 offset;
	float3 samplingDir;

	// Do colour.
	//
	// We need to sample multiple pixels and average them because
	// the cubemap resolution tends to be bigger (otherwise glitches caused
	// by rasterization rules become apparent), so we may be converting a cubemap of 32x32x6 to
	// a 2D octahedral map of 6x6 or 8x8
	float4 colourData = float4( 0, 0, 0, 0 );
	/// Note: There is no vert_samples_per_colour_pixel (Because width == height)
	@foreach( y, horiz_samples_per_colour_pixel )
		@foreach( x, horiz_samples_per_colour_pixel )
			offset = float2( @x, @y ) / ( @value( horiz_samples_per_colour_pixel ) * @value( colour_full_width ) );
			samplingDir = octahedronMappingDecode( samplingXY + offset );
			colourData += OGRE_SampleLevel( colourCubemap, bilinearSampler, samplingDir, 0 );
		@end
	@end

	colourData /= @value( samples_per_colour_pixel );
	OGRE_imageWrite2D4( irradianceField, iColourXY, colourData );

	// Do depth
	//
	// This is like depth. While depth res >= colour res; typically 12x12 or 16x16;
	// we (usually, using default params) have 4 times as many depth pixels than colour.
	// And this pixel shader run one thread per colour pixel; thus each thread handles
	// more than one depth pixel
	float depthData;
	@foreach( i, depth_to_colour_resolution_ratio )
		@foreach( j, depth_to_colour_resolution_ratio )
			depthData = 0.0f;
			@foreach( y, horiz_samples_per_depth_pixel )
				@foreach( x, horiz_samples_per_depth_pixel )
					offset = float2( @i + @x, @j + @y ) / ( @value( horiz_samples_per_depth_pixel ) * @value( depth_full_width ) );
					samplingDir = octahedronMappingDecode( samplingXY + offset );
					depthData += OGRE_SampleLevel( depthCubemap, bilinearSampler, samplingDir, 0 );
				@end
			@end

			depthData /= @value( samples_per_depth_pixel );
			OGRE_imageWrite2D1( irradianceFieldDepth, iDepthXY + ushort2( @i, @j ), depthData );
		@end
	@end
@end
